/*
* （1）魔方阵
* ①问题描述
* 魔方阵是一个古老的智力问题，它要求在一个 m×m 的矩阵中填入 1～m
* 2的
* 数字（m 为奇数），使得每一行、每一列、每条对角线的累加和都相等，如图 1
* 所示。
* 15 8 1 24 17
* 16 14 7 5 23
* 22 20 13 6 4
* 3 21 19 12 10
* 9 2 25 18 11
* 图 1 五阶魔方阵示例
* ②基本要求
* -  输入魔方阵的行数 m，要求 m 为奇数，程序对所输入的 m 作简单的判
* 断，如 m 有错，能给出适当的提示信息。
* -  实现魔方阵。
* -  输出魔方阵。
* ③思考
* -  可以考虑使用其他方法生成魔方阵。任何算法都有不同的实现方法，通
* 过采用不同实现方法来重新实现算法，这要比单纯学习算法的效果好得
* 多。
* （2）本科生导师制问题
* 20
* ①问题描述
* 在高校的教学改革中，有很多学校实行了本科生导师制。一个班级的学生被
* 分给几个老师，每个老师带 n 个学生，如果该老师还带研究生，那么研究生也可
* 直接带本科生。本科生导师制问题中的数据元素具有如下形式：
* -  导师带研究生
* （老师，（（研究生 1，（本科生 1，…，本科生 m1）），（研究生 2，
* （本科生 1，…，本科生 m2））…））
* -  导师不带研究生
* （老师，（本科生 1，…，本科生 m））
* 导师的自然情况只包括姓名、职称；研究生的自然情况只包括姓名、班级；
* 本科生的自然情况只包括姓名、班级。
* ②基本要求
* 要求完成以下功能：
* -  建立：建立导师广义表。
* -  插入：将某位本科生或研究生插入到广义表的相应位置。
* -  删除：将某本科生或研究生从广义表中删除。
* -  查询：查询导师、本科生（研究生）的情况。
* -  统计：某导师带了多少个研究生和本科生。
* -  输出：将某导师所带学生情况输出。
* -  退出：程序结束。
* ③思考
* 可以考虑对程序做如下完善：
* -  可以将学生从一个导师组转到另一个导师组。
* -  可以在同一个导师组内修改本科生的研究生负责人。
* -  当研究生带本科生时，如果要删除该研究生，可根据情况，将本科生平
* 均分配给该导师的其他研究生，如果没有其他研究生，则由导师直接负
* 责。
* -  增加删除导师的功能。
* 查询时，如果待查人员是导师，除了输出本人信息外，还输出他所指导的学生信
* 息；如果待查人员是研究生，除了输出其导师和本人信息外，还输出他所负责的
* 本科生信息。

*/

#include <iostream>
#include <iomanip>
#define M 50
using namespace std;
class MCA
{
public:
    void MagicCubeArray1(int n);
    bool IsOddNumber(int n);
};

bool MCA::IsOddNumber(int n)
{
    if(n % 2 == 0) {
        cout<<"请输入奇数"<<endl;
        return true;
    }else {
        return false;
    }
}

void MCA::MagicCubeArray1(int n)
{

    if(!IsOddNumber(n)) {
        int i, j, num;
        int i1, j1; //i1, j1为操作时的行数和列数
        int array[M][M];
        for(i = 1; i < n+1; ++i) {
            for(j = 1; j < n+1; ++j) { //数字初始化为零 来记录是否摆放数字
                array[i][j] = 0;
            }
        }
        i = 1;
        j = n/2 + 1; 
        array[i][j] = 1;//1位于第一行的正中间

        for(num = 2; num <= n*n; ++num) { //数字的摆放
            //上一行，下一列
            i1 = i;
            j1 = j;
            i--;
            j++;
            
            //可能的三种情况
            if(i == 0){ //没有上一行
                i = n;
            }
            if(j > n) { //没有下一列
                j = 1;
            }
            if(array[i][j] != 0) { //位置已经摆放数字了
                //向下一行，列数不变
                i = i1 + 1;
                j = j1;
            }
            //摆放数字
            array[i][j] = num;
        }
        for(i = 1; i < n+1; ++i) { //输出矩阵
            for(j = 1; j < n+1; ++j) {
                cout<<setw(6)<<array[i][j];
            }
            cout<<endl;
        }
    }  
}

int main() {
    MCA * mca = new MCA;
    int n;
    while(1) {
        cin>>n;
        if(mca->IsOddNumber(n)) {
            continue;
        }else break;
    }
    mca->MagicCubeArray1(n);
    return 0;
}